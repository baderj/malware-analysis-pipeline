from __future__ import annotations
import pkgutil
import importlib
import plugins

from argparse import ArgumentParser
from ast import Or
from itertools import chain
from utils.state import State
from collections import OrderedDict

class AbstractPlugin:

    def __init__(self):
        pass

    def run(self, args: dict) -> None:
        raise NotImplementedError("Each plugin needs to implement this")

    def load_argparser(self, parser: ArgumentParser) -> None:
        raise NotImplementedError("Each plugin needs to implement this")

    @staticmethod
    def load_plugins() -> dict:
        

        discovered_plugins = {
            name: importlib.import_module(name)
            for finder, name, ispkg,
            in pkgutil.iter_modules(plugins.__path__,
                                    plugins.__name__ + ".")
        }

        plugins_to_load = State.config['plugins']['run_order']
        plugins_to_load = plugins_to_load.split(',')
        plugins_to_load = [plugin.strip() for plugin in plugins_to_load]
        plugins_dict = OrderedDict().fromkeys(plugins_to_load)

        for plugin_name, plugin in discovered_plugins.items():
            _, call_name = plugin_name.rsplit('.', 1)
            if call_name not in plugins_to_load:
                continue
            importlib.import_module(plugin_name)
            instance = getattr(plugin, plugin.class_name)()
            plugins_dict[call_name] = instance
        return plugins_dict